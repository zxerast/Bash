# Тесты для проекта "Shell"

## Тесты ввода команд
1. Тест на ввод пустой команды
   - Ввод: ``
   - Ожидаемый результат: нет выделения памяти, нет обработки команды, переход к следующему вводу.
2. Тест на ввод команды с пробелами
   - Ввод: `   `  
   - Ожидаемый результат: либо игнорирование ввода, либо после лексического анализа команда считается пустой и парсинг не выполняется, переход к следующему вводу.
3. Тест на CTRL+D для выхода
   - Ввод: `CTRL+D`
   - Ожидаемый результат: при пустом вводе происходит выход из программы без ошибок, при наличии текста в буфере либо игнорирование, либо flush буфера (продожение/завершение на выбор).
4. Тест на ввод команды с аргументами
   - Ввод: `ls -la /home/user`
   - Ожидаемый результат: команда и аргументы корректно распознаны и переданы на выполнение.
5. Незавершённая строка
   - Ввод: 
	 ```
	 echo "Hello
	 World"
	 ```
   - Ожидаемый результат: программа ожидает завершения ввода (например, закрывающей кавычки) перед выполнением команды. Обрабатывается в lexer.
6. Незавершенная команда с операторами
   - Ввод:
	 ```
	 ls -l |
	 grep "txt"
	 ```
   - Ожидаемый результат: программа ожидает завершения ввода (например, следующей команды после оператора) перед выполнением. Обрабатывается в parser.
7. Многострочный ввод с обратным слэшем (как часть доп. задания)
   - Ввод:
	 ```
	 echo "This is a \
	 test"
	 ```
   - Ожидаемый результат: команда распознана как одна строка и выполнена корректно. Обрабатывается в readline/lexer.

В пунтках 5, 6 и 7 при завершении ввода печатается упрощенный prompt (на выбор разработчика).

## Тесты лексического анализатора (lexer)

1. Тест на любое количество пробельных символов между токенами
   - Ввод: `ls     -la    /home/user`
   - Ожидаемый результат: токены распознаны корректно, пробельные символы игнорируются.
2. Тест на присутствие/отсутствие пробелов вокруг операторов
   - Ввод: `cat file.txt|grep "search"| wc -l`
   - Ожидаемый результат: операторы распознаны корректно, независимо от наличия пробелов.
3. Тест на внутренние кавычки
   - Ввод: `'echo "Hello World"'` или `"echo 'Hello World'"`
   - Ожидаемый результат: строка внутри кавычек распознана как один токен.
4. Специальные символы внутри кавычек
   - Ввод: `echo "This | is > a test"`
   - Ожидаемый результат: спецсимволы внутри кавычек распознаны как часть строки, а не как операторы.
5. Экранирование кавычек
   - Ввод: `echo "He said, \"Hello World\""`
   - Ожидаемый результат: кавычки внутри строки распознаны корректно.
6. Экранирование вне кавычек спецсимволов
	- Ввод: `echo Hello\ World` или `echo Hello\|World`
	- Ожидаемый результат: пробел или спецсимвол распознаны как часть токена.
7. Последовательные операторы
   - Ввод: `ls -l ||| grep "txt"`
   - Ожидаемый результат: лексер должен быть жадным и распознавать максимальные последовательности операторов (например, `||` и `|`).
8. Неизвестные или некорректные символы
   - Ввод: `ls -l $%^&*`
   - Ожидаемый результат: лексер должен обрабатывать любые неспецсимволы как часть токенов, не вызывая ошибок.
9. Пустые кавычки
   - Ввод: `echo "" ''`
   - Ожидаемый результат: пустые строки распознаны как отдельные токены.
10. Теста на слово, часть которого является строка
	- Ввод: `echo He"llo"Wo'rld'`
	- Ожидаемый результат: либо токен распознается как единое слово `HelloWorld`, либо выдается ошибка (на выбор разработчика).
11. Тест на $ и = внутри токена
	- Ввод: `echo $HOME` или `echo VAR=VALUE`
	- Ожидаемый результат: токен распознается как слово без специальной обработки символа $ или = (обработка на поздних этапах).

## Тесты синтаксического анализатора (parser)

- Ожидаемая реализация: списки или деревья команд с учётом приоритетов операторов и правил синтаксиса.
- Ожидается обработка ошибок синтаксиса с информативными сообщениями.

1. Тест на корректный ввод простой команды
   - Ввод: `ls -la /home/user`
   - Ожидаемый результат: команда и аргументы распознаны корректно, структура данных построена правильно.
2. Тест на ввод команды с редиректами
   - Ввод: `cat < input.txt > output.txt`
   - Ожидаемый результат: команда и редиректы распознаны корректно, структура данных построена правильно.
3. Тест на ввод без команды (только редиректы)
	- Ввод: `< input.txt > output.txt`
   - Ожидаемый результат: либо команда и редиректы распознаны корректно, либо ошибка синтаксиса
4. Тест на произвольный порядок и количество редиректов
   - Ввод: `grep "search" > output.txt < input.txt >> append.txt -s`
   - Ожидаемый результат: команда и все редиректы распознаны корректно, структура данных построена правильно.
3. Тест на отсутствие названия файла при редиректе
   - Ввод: `cat < > output.txt`
   - Ожидаемый результат: ошибка синтаксиса
4. Тест на отсутствие команды перед и между операторами
   - Ввод: `| grep "txt" || wc -l`
   - Ожидаемый результат: ошибка синтаксиса
5. Тест на последовательные операторы без команд между ними
   - Ввод: `ls -l ||| grep "txt"`
   - Ожидаемый результат: ошибка синтаксиса
6. Тест на вложенные команды с бинарными операторами (|, &&, ||, ;, &)
   - Ввод: `cat file.txt | grep "search" && echo "Found" & echo "Not Found"`
   - Ожидаемый результат: команды и операторы распознаны корректно, структура данных построена правильно.
7. Тест на завершение последовательности токенов оператором ; или &
   - Ввод: `ls -l ;`
   - Ожидаемый результат: команда распознана корректно, оператор ; или & считается завершением последовательности команд.

## Тесты на семантический анализ/расширение переменных окружения
1. Тест на расширение переменных окружения (и шелла в случае поддержки этой функциональности)
   - Ввод: `echo $HOME`
   - Ожидаемый результат: `$HOME` расширяется до пути домашнего каталога пользователя. Если переменная не установлена, выводится пустая строка.
2. Тест на отсутствие расширения внутри одинарных кавычек
   - Ввод: `echo '$HOME'`
   - Ожидаемый результат: выводится строка `$HOME` без расширения.
3. Тест на расширение внутри двойных кавычек
   - Ввод: `echo "My home is $HOME"`
   - Ожидаемый результат: `$HOME` расширяется до пути домашнего каталога пользователя внутри строки.
4. Тест на расширение вне кавычек
   - Ввод: `echo Hello $USER`
   - Ожидаемый результат: `$USER` расширяется до имени текущего пользователя.
5. Тест на создание новой переменной (в случае поддержки этой функциональности)
   - Ввод: `var=value`
   - Ожидаемый результат: переменная `var` создается с значением `value` и добавляется в окружение (шелла)
6. Тест на отсутствие значения перед знаком равенства (в случае поддержки этой функциональности)
   - Ввод: `=value`
   - Ожидаемый результат: ошибка синтаксиса или игнорирование ввода
7. Тест на отсутствие значения после знака равенства (в случае поддержки этой функциональности)
   - Ввод: `var=`
   - Ожидаемый результат: переменная `var` создается с пустым значением и добавляется в окружение (шелла)
8. Тест на создание нескольких переменных за один ввод (в случае поддержки этой функциональности)
   - Ввод: `var1=value1 var2=value2`
   - Ожидаемый результат: обе переменные создаются с соответствующими значениями и добавляются в окружение (шелла) (в любом порядке)

## Тесты выполнения команд
1. Тест на выполнение встроенной команды
   - Ввод: `cd /tmp`
   - Ожидаемый результат: Если встроенная команда не в конвейере или фоне, выполняется самим шеллом (текущий процесс меняет директорию).
2. Тест на редирект для встроенной команды
   - Ввод: `echo "Hello World" > output.txt`
   - Ожидаемый результат: встроенная команда выполняется с перенаправлением вывода в файл (создавая бэкап оригинальных потоков).
3. Тест на выполнение внешней команды
   - Ввод: `ls -la /home/user`
   - Ожидаемый результат: внешняя команда выполняется в дочернем процессе с корректными аргументами (если найдена в PATH).
4. Тест на конвейер команд
   - Ввод: `cat file.txt | grep "search" | wc -l`
   - Ожидаемый результат: команды выполняются в конвейере с корректным перенаправлением потоков между ними. Допускается использование 1 пайпа (не массив пайпов).
5. Тест на блокировку шелла при выполнении команды
   - Ввод: `sleep 5` или `ls | wc -l`
   - Ожидаемый результат: шелл блокируется до завершения выполнения команды или конвейера.
6. Тест на сигналы при выполнении команды
   - Ожидаемый результат: шелл игнорирует или обрабатывает сигналы, дочернием процессы получают стандартную обработку сигналов
7. Тест на выполнение команды в фоне
   - Ввод: `sleep 10 &` или `sleep 10 | wc -l &`
   - Ожидаемый результат: команда выполняется в фоне, шелл не блокируется и готов к вводу новых команд.
8. Тест на редирект ввода/вывода
   - Ввод: `grep "search" < input.txt > output.txt`
   - Ожидаемый результат: ввод при несуществующем файле вызывает ошибку, вывод перенаправляется в указанный файл (создавая файл, если он не существует).
9. Тест на && и ||
   - Ввод: `false && echo "This will not print"` и `true || echo "This will not print"`
   - Ожидаемый результат: в первом случае вторая команда не выполняется, во втором случае вторая команда не выполняется.
10. Тест на последовательное выполнение команд с ; или &
	- Ввод: `echo "First"; echo "Second"` или `echo "First" & echo "Second"`
   - Ожидаемый результат: обе команды выполняются последовательно или параллельно в фоне.

## Тесты на job control

- Все не фоновые процессы должны быть в своей собственной группе процессов. Шел передает управление терминалом группе процессов текущей команды/конвейера, сохраняя настройки терминала для себя. После завершения команды/конвейера шелл должен вернуть управление терминалом себе.

- Шелл должен обрабатывать в начале основного цикла события от дочерних процессов (SIGCHLD) и обновлять статусы задач. Обрабатываются следующие статусы: выполняется (в фоне), остановлена, завершена. При изменении статуса задачи шелл должен обновлять внутреннее состояние каждого процесса, статус задачи агррегируется по статусам процессов.

1. Тест на выполнение команды в фоне с job control
   - Ввод: `sleep 30 &`
   - Ожидаемый результат: команда выполняется в фоне, шелл не блокируется, управление терминалом возвращается шеллу.
2. Тест на выполнение конвейера в фоне с job control
   - Ввод: `cat file.txt | grep "search" &`
   - Ожидаемый результат: конвейер выполняется в фоне, шелл не блокируется, управление терминалом возвращается шеллу.
3. Если не фоновая задача остановилась (например, по SIGTSTP), шелл должен вернуть управление терминалом себе.
   - Ввод: `sleep 30` затем `CTRL+Z`
   - Ожидаемый результат: задача останавливается, шелл возвращает управление терминалом себе, статус задачи изменяется на "остановлена".
4. Тест на обработку сигналов в фоне
   - Ввод: `sleep 30 &` затем `kill -SIGTSTP <pid>`
   - Ожидаемый результат: фоновая задача останавливается, шелл продолжает работать без блокировки, статус задачи изменяется на "остановлена".
5. Тест на возобновление через SIGCONT
   - Ввод: `sleep 30 &` затем `kill -SIGTSTP <pid>` затем `kill -SIGCONT <pid>`
   - Ожидаемый результат: задача возобновляется, шелл продолжает работать без блокировки, статус задачи изменяется на "выполняется" (в фоне).
6. Тест на завершение фоновой задачи
   - Ввод: `sleep 10 &` затем ожидание завершения
   - Ожидаемый результат: задача завершается, шелл продолжает работать без блокировки, статус задачи изменяется на "завершена".
7. Тест на частичное завершение/остановку/возобновление задач в конвейере
   - Ввод: `cat file.txt | grep "search" &` затем `kill -SIGTSTP <pid_of_grep>`
   - Ожидаемый результат: только процесс grep останавливается, процесс cat продолжает выполняться, статус задачи обновляется соответственно.

