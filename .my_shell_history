hello world
sudo apt install
clear
hello world
clear
hello world
sudo
frederiko
kadel
ls -l | grep txt; echo hello && echo ok
ls -l || grep txt; echo hello && echo ok
ls -l  grep txt; echo hello && echo ok
ls
ls -l
ls der
ls der gaher few
ls > out.txt
echo; pipe
ls; pwd; echo hi
ls & echo & pwd
ls & echo &
;;;;
ls > out.txt
echo Hello
pwd
whoami
cat /etc/host
cat /etc/hosts
clear
echo hi > a.txt
cat a.txt
clear
echo world >> a.txt
cat a.txt 
clear
cat < a.txt
ls nosuchfile &> err.txt
cat err.txt
clear
ls | cat
clear
ls | grep txt
clear
ls | wc -l
clear
cat /etc/passwd | grep root | wc -l
ls | grep .c | sort | uniq | wc -l
clear
ls | wc -l > count.txt
cat count.txt
clear
echo "hello world"
world"
there
echo japanece #ksdlkfjgjsdf
clear
cat dslfkjhds | grep txt
clear
echo a; echo b
clear
ls && echo yes
clear
echo ok
pwd
ls | wc -l
ksajdsa
df
f
df
clear
kkdjf
clear
cd
ls
cd src
cd /src
clear
clear
hello
hello
hi /
echo hi /
me
hel
exit
pwd
help
ls
cat dslfkjhds | grep txt
ls | wc -l
cat /etc/passwd | grep root | wc -l
ls | grep
ls | grep -m
clear
ls | grep txt
ls
ls | grep md
ls saasd | cat
ls saasfsa |& cat
ls saasd | cat
ls saasfsa |& cat
ls | grep md
ls |& grep md
ls asdsad | cat > out.txt
ls asdsad |& cat > out.txt
sdfsd
ls &
ls;
ls &
echo a | echo b | echo c
cat < file | grep text
echo hello | cat > out.txt
echo A && sleep 2 &
echo a | grep a && echo ok
echo a | grep a && echo ok
echo a | grep a && echo ok
echo a | grep a && echo ok
echo a | grep a && echo ok
echo a | grep a && echo ok
echo a | grep a && echo ok
echo a | grep a && echo ok
clear
false | cat || echo yes
ps -elf | grep Z
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
cle
clear
sleep 1 &
ps -elf | grep Z
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
sleep 1 &
ps -elf | grep Z
ps -elf | grep Z
ls &
pwd
ls | grep txt
ls &
ls &
ls &
ls &
sleep 1 &
sleep 1 &
sleep 1 &
clear
ls &
clear
pwd &
clear
ls &
ls | grep txt &
ls | grep txt &
clear
ls &
pwd &
pwd &
pwd & ls
ls &
cle
ls &
ls & pwd
clear
ls &
ls &
ls & pwd
ls &
ls & pwd
clear
ls &
clear
sleep 5 | cat
sleep 5 | cat
clear
sleep 5 | cat
sleep 100 | cat | cat
clear
yes | sleep 10
yes | sleep 10
yes | sleep 10
yes | sleep 1
exit
yes | sleep 5
echo foo | cat foo
echo foo | cat
ls
sleep 5
pwd
echo Hi
ls -l /home
help
clear
history
history
echo hi | cd /tmp
echo hi | cd /
echo hi | cd 
echo hi | cd /mnt
cd | echo hi
cd | echo hi
cd | echo hi
echo hi | cd
echo hi | cd
echo hi | cd /
ls
cd /game
cle
clear
sleep 10
sleep 5
fg %1
sleep 5
sleep 5
sleep 5
sleep 5
sleep 5
sleep 5
sleep 5
sleep 5
sleep 5 | sleep 6
ls | ls
ppid | ppid | ppid
ppid | ppid
ppid | ppid | ppid
world" | cat | cat | cat
seq 5 | grep 3 | wc -l
yes | head
yes | grep aaa | wc -l
ls
ls || sleep 3
ls || sleep 3
ls || sleep 3
clear
ls ||
ls |
ls | >>
ls || >>
clear
ls /root
cat < /etc/passwd | head -n 5 | cut -d: -f1
clear
seq 1000 | grep 1 | grep 2 | grep 3 | grep 4 | grep 5 | grep 6 | grep 7 | grep 8 | grep 9 | wc -l
seq 1000 | grep 1 | grep 2 | grep 3 | grep 4 | grep 5 | grep 6 | grep 7 | grep 8 | grep 9 | wc -l
cle
clear
yes | head -n 5 &
ls gard |& grep denied
ls gard |& grep
ls gard |& grep No
clear
ls gard |& grep No | cat | grep such | cat
sleep 3; sleep 3
sleep 5 &
clear
sleep 5
sleep 5 &
clear
sleep 5 &
sleep 5 &
ccd]
sleep 5 &
sleep 5 &
sleep 5 &
ss
s
sleep 3 | sleep 4 | sleep 5
sleep 3
sleep 3
clear
sleep 3
sleep 3
sleep 3
sleep 3
sleep 3
sleep 3
sleep 3 | sleep 4
sleep 3
sleep 3 &
sleep 5 &
sleep 5 &
sleep 5
sleep 5 &
sleep 5
clear
sleep 5 &
sleep 5 &
sleep 4 | sleep 5 &
sleep 4 | sleep 5 
sleep 4
sleep 3 | sleep 4
sleep 3; sleep 4
sleep 4
sleep 4 &
sleep 4 ;
sleep 5 & sleep 1
sleep 5 & sleep 1
sleep 5 & sleep 1
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 5; sleep 4; sleep 3 
sleep 3; sleep 4; sleep 5
cle
clear
sleep 3; ls
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
sleep 3; sleep 4; sleep 5
ls
sleep 3 | sleep 2
sleep 5; sleep 5; sleep 4
jobs
jobs
sleep 5; sleep 5; sleep 4
jobs
clear
sleep 5; sleep 5; sleep 4
jobs
sleep 1; sleep 1; sleep 1
jobs
clear
jobs
clear
sleep 1
jobs
jobs
sleep 1
jobs
sleep 1
jobs
sleep 1
jobs
sleep 3
sleep 3 &
fg 1
sleep 3
fg 1
clear
jobs
bg %1
fg %1
fg %2
bg %2
sleep 10 &
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
sleep 3 &
jobs
jobs
sleep 10 &
sleep 10 &
jobs
jobs
sleep 10 &
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
sleep 10 &
jobs
jobs
jobs
sleep 10 &
jobs
jobs
clear
sleep 10 &
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
sleep 1 &
jobs
jobs
jobs
jobs
clear
sleep 3 &
jobs
jobs
jobs
jobs
sleep 3
jobs
sleep 3
jobs
jobs
jobs
sleep 3
jobs
sleep 3
jobs
sleep 3
jobs
sleep 3 &
jobs
jobs
jobs
jobs
clear
sleep 3 &
jobs
sleep 3 &
jobs
jobs
jobs
jobs
sleep 3 &
jobs
jobs
sleep 3 &
jobs
sleep 3 &
sleep 3 &
jobs
jobs
sleep 3 &
jobs
sleep 3 &
sleep 3 &
jobs
jobs
sleep 3
jobs
jobs
sleep 3 &
jobs
clear
jobs
sleep 3 &
jobs
jobs
sleep 3
jobs
sleep 1
jobs
sleep 5
sleep 5
sleep 2
sleep 2
sleep 2
jobs
sleep 2
sleep 2 &
jobs
jobs
jobs
jobs
sleep 2 
jobs
clear
sleep 2 
sleep 2 
jobs
sleep 2 
sleep 2 
sleep 2  &
jobs
clear
sleep 2
jobs
sleep 2
jobs
sleep 2
jobs
jobs
cle
clear
sleep 2 &
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
history
clear
sleep 2 &
jobs
jobs
jobs
sleep 1
jobs
sleep 1
sleep 1
sleep 1 &
jobs
jobs
sleep 1 &
jobs
sleep 1 &
sleep 1 &
sleep 2
jobs
sleep 2 &
jobs
jobs
jobs
jobs
jobs
jobs
sleep 2 &
jobs
jobs
jobs
jobs
jobs
sleep 2
jobs
jobs
jobs
jobs
fg %1
fg 1
jobs
clear
jobs
sleep 10 &
jobs
fg 1
sleep 10
sleep 10 &
fg 1
sleep 10 &
jobs
jobs
jobs
clear
sleep 10
jobs
bg 1
fg 1
sleep 10
bg 1
jobs
jobs
jobs
sleep 100 &
kill 1
kill %1
jobs
jobs
sleep 100 &
jobs
kill %1
jobs
clear
world"
wc
clea
clear
"
"
"
"
"
"
"
echo \"hello\"
"
echo \"hello\" 
clear
echo hello | tr a-z A-Z
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello | tr a-z A-Z | rev
echo hello |  tr a-z A-Z | rev
echo hello |tr a-z A-Z | rev
ls /fsd/ass |& grep
ls /fsd/ass |& grep denied
ls /fsd/ass |& grep no
echo test > x.txt
echo test > x.txt
ls
echo "man" > x.txt
echo test > x.txt
echo test > x.txt
echo test > x.txt
echo test > x.txt
echo test > x.txt
cat x.txt 
echo a > x.txt 
echo b >> x.txt 
cat x.txt 
clear
cat < her.txt
clear
echo A; echo B
clear
echo hello | tr l L; echo done
clear
false && echo YES
false || echo YES
true && echo OK || echo FAIL
clear
sleep 2 &
clear
clear
sleep 10 &
jobs
jobs
jobs
jobs
jobs
clear
sleep 5 &
sleep 5 &
jobs
jobs
jobs
jobs
clear
echo A & echo B
jobs
jobs
clear
echo hello | tr l L &
clear
sleep 20
bg 1
jobs
jobs
jobs
clear
sleep 1000 &
kill %1
jobs
jobs
clear
sleep 1000 &
kill -9 %1
jobs
jobs
clear
yes | head -n 3
sleep 2 | cat
sleep 5 | sleep 5
clear
echo A & echo B & echo C | tr A-Z a-z &
clear
yes | head -n 100000 &
echo "a \" escaped"
fg
bg
fg 67
bg 67
sleep 100&
jobs
kill 1
kill %1
jobs
clear
sleep 100&
jobs
jobs -l
kill 21367
jobs
clear
jobs
clear
hello > "filer"
echo hi > a
echo hi | wc -c
sleep 1 &
sleep 1 &
jobs
jobs
clear
echo hi > a
echo hi | wc -c
sleep 1 &
sleep 1 &
jobs
echo \"hello\"
"
clear
echo 123 > a.txt
echo 123 > a.txt
echo 123 > a.txt
cat a.txt 
echo >> 456
echo 456 >> a.txt 
echo hello > b
cat < b
ls dsds
ls dsds &> err.txt
cat err.txt 
clear
cat < b.txt > c.txt
cat < b > c
cat c
clear
echo hi | cat
cat
clear
sleep 1
sleep 5
jobs
fg 1
jobs
fg %1
fg %1
fg 1
clear
sleep 5
jobs
jobs
fg 1
sleep 10
fg 1
sleep 10
jobs
fg 1
clear
sleep 5 | sleep 1
sleep 5 | sleep 1
jobs
clear
sleep 10 &
jobs
jobs
jobs
jobs
jobs
clear
sleep 10 
jobs
jobs
bg 1
jobs
jobs
sleep 10 &
fg 1
clear
sleep 10 | sleep 20 | sleep 30 &
jobs
jobs
jobs
jobs
fg 1
fg 1
jobs
clear
jobs
fg 1
echo
echo he
sleep 3 | sleep 4
sleep 3 | sleep 4
jobs
sleep 3 | sleep 4
jobs
sleep 3
clear
clear
sleep 10
sleep 10
sleep 10
sleep 10
sleep 10 | sleep 5
jobs
fg 1
jobs
jobs
clear
clear
clear
clear
clear
sleep 3
jobs
fg 1
jobs
sleep 10
jobs
fg 1
sleep 10 &
jobs
jobs
jobs
jobs
jobs
jobs
clear
echo home
echo $HOME
$HOME
HOME
$HOME
echo $HOME
ls $HOME
cd $HOME
clear
echo "$HOME"
cd $HOME
export TEST=/
ls TEST
ls $TEST
ls
ls /
export TEST=BABA YAGA
echo $TEST
echo $HOME
sleep 10 | sleep 10| sleep 10
jobs
fg 1
fg 1
jobs
clear
sleep 10 | sleep 10| sleep 10 &
jobs
fg 1
sleep 100 | sleep 100 | sleep 100
fg 1
jobs
bg 1
jobs
jobs
sleep 100 | sleep 100 | sleep 100
jobs
bg 1
jobs
fg 1
jobs
sleep 100
jobs
ps 
ps 
jobs
bg 1
jobs
jobs
clear
sleep 100 &
ps
ps
ps
jobs
export x=54
echo $x
x=54
sleep 100
ps
jobs
fg 1
fg 1
jobs
ps
clear
sleep 100
ps
jobs
jobs
jobs
clear
jobs
fg 1
jobs
bg 1
jobs
clear
jobs
jobs
clear
sleep 100 &
jobs
fg 1
jobs
fg 1
jobs
bg 1
jobs
ps
jobs
jobs
jobs
jobs
jobs
jobs
clear
sleep 100 &
jobs
ps
jobs
jobs
clear
sleep 100 &
fg 1
jobs
ps
jobs
jobs
fg 1
jobs
jobs
jobs
jobs
jobs
jobs
clear
clear
jobs
jobs
jobs
jobs
clear
clear
clear
clear
clear
fg 1
clear
sleep 100 | sleep 100 | sleep 100
ps
jobs
fg 2
jobs
ps
jobs
jobs
jobs
clear
jobs
jobs
jobs
jobs
jobs
jobs
jobs
jobs
clear
jobs
ps
sleep 100 | sleep 100 | sleep 100
bg 1
jobs
fg 1
clar
clear
fg 1
fg 1
fg 1
clear
clear
ertj
ertjwert
clear
ls
clear
ls -l
jobs
fg 1
jobs
clear
ls -l
clear
ls -l
clear
ls -l
clear
ls|
jobs
clear
ls |
ls | ls
clear
ls || ls
ls | ls
clear
ls && ls
ls ; ls
clear
echo hello | cat
clear
ls /etc | grep '^p' | head -3
clear
seq 1 5 | awk '{print \$1*2}'
seq 1 5 | awk '{print $1*2}'
seq 1 5 | awk '{print \$1*2}'
clear
echo -e 'a/nb/na/nc' | sort | uniq
clear
ps aux | wc -l
clear
cat /etc/passwd | cut -d: -f1 | sort | head -5
clear
echo "apple\nbanana\ncherry\n"
echo "apple\nbanana\ncherry\n" > fruits.txt
ls
vim fruits.txt 
clear
cat > slow_cat.sh << 'EOF'
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
cat > slow_cat.sh
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
clear
cat > slow_cat.sh << "EOF"
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
#include "parser.h"
ASTNode *parse(Token *head)
{
    return parse_sequence(head);  
}
ASTNode *parse_sequence(Token *head){   // по приоритету начинаем вызов с самого низкого
    Token *tmp = head;
    while (head->type != BACKGROUND && head->type != SEPARATOR){    // пока не встретили ; или &
        if(head->type == END) return parse_and_or(tmp); // если не нашли, то парсим дальше по приоритету
        head = head->next;  // идём дальше по списку токенов
    }
    ASTNode *node = new_ast_node(NODE_SEQ, head->type); // создаём новый узел если нашли ; или &
    head->type = END;   // разделяем список токенов на две части END токеном в месте разделителя
    node->left = parse_and_or(tmp); // парсим в левой части следующую по приоритету часть
    node->right = parse(head->next); // в правой части дальше ищем возможный текущий приоритет
    return node;
}
ASTNode *parse_and_or(Token *head){       // Далее точно такая же логика, только для следующих приоритетов
    Token *tmp = head;
    while (head->type != AND_IF && head->type != OR_IF){
        if(head->type == END) return parse_pipeline(tmp);
        head = head->next;
    }
    ASTNode *node = new_ast_node(NODE_AND_OR, head->type);
    head->type = END;
    node->left = parse_pipeline(tmp);
    node->right = parse(head->next);
    return node;
}
ASTNode *parse_pipeline(Token *head){
    Token *tmp = head;
    while (head->type != PIPE && head->type != PIPE_AND){
        if(head->type == END) return parse_command(tmp);
        head = head->next;
    }
    ASTNode *node = new_ast_node(NODE_PIPE, head->type);
    head->type = END;
    node->left = parse_command(tmp);
    node->right = parse(head->next);
    return node;
}
ASTNode *parse_command(Token *head){
    ASTNode *node = new_ast_node(NODE_COMMAND, head->type); 
    node->left = NULL;  // команды не имеют потомков как самый верхний приоритет
    node->right = NULL;
    node->argv = NULL;
    node->redirects = NULL;
    size_t argc = 0;
    Token *tmp = head;
    while (tmp->type != END) {  // создаём массив из слов которые будут образовывать команду
        switch (tmp->type) {
            case WORD:
            case STRING: {
                node->argv = realloc(node->argv, sizeof(char *) * (argc + 2));
                node->argv[argc] = strdup(tmp->value);
                argc++;                    // слово или строка добавляются в аргументы команды
                node->argv[argc] = NULL; 
                break;
            }
            case REDIRECT_IN:
            case REDIRECT_OUT:
            case REDIRECT_APPEND:
            case REDIRECT_ERR:
            case REDIRECT_FAR: {
                if (!tmp->next || tmp->next->type != WORD) {    // после перенаправления должно идти имя файла
                    fprintf(stderr, "Syntax error: expected filename after redirection\n");
                    free_ast(node);
                    return NULL;
                }
                Redirect *r = malloc(sizeof(Redirect)); // создаём структуру перенаправления в виде списка
                r->type = tmp->type;    
                r->filename = strdup(tmp->next->value); 
                r->next = NULL;
                if (!node->redirects) node->redirects = r;  // добавляем в конец списка перенаправлений
                else {
                    Redirect *tmp = node->redirects;
                    while (tmp->next) tmp = tmp->next;  // иначе идём до конца списка и потом добавляем
                    tmp->next = r;
                }
                tmp = tmp->next; // пропускаем имя файла
                break;
            }
            default:
                fprintf(stderr, "Syntax error %d \n", tmp->type);
                free_ast(node);
                return NULL;
        }
        tmp = tmp->next;
    }
    if (!node->argv || !node->argv[0]) {
        free_ast(node);     // нет аргументов - нет и команды
        return NULL;
    }
    return node;
}
cle
clear
# Создаем замедленную команду
cat > slow_cat.sh << 'EOF'
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
# Создаем замедленную команду
cat > slow_cat.sh << 'EOF'
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
# Создаем замедленную команду
cat > slow_cat.sh << 'EOF'
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
jobs
cat > slow_cat.sh << 'EOF'
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
# Создаем замедленную команду
cat > slow_cat.sh << 'EOF'
#!/bin/bash
while read line; do
    echo "Processing: $line" >&2
    echo "$line"
    sleep 0.1
done
EOF
chmod +x slow_cat.sh
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
clear
ls
ls
cle
clear
ls
clear
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
clear
printf 'line1\nline2\nline3\n' | ./slow_cat.sh | grep 'line'
clear
:(){ :|: & };;
:(){ :|: & };:
clear
ertj ma
dd      d
d        d
ls -l
clear
ls|ls
clear
ls|
clear
ls||ls
clear
ls&&ls
clear
ls; ls
clear
echo hello | cat
clear
ls /etc | grep '^p' | head -3
clear
seq 1 5 | awk '{print \$1*2}'
clear
echo -e 
clear
ps aux | wc -l
ps aux | wc -l
ps aux | wc -l
ps aux | wc -l
ps aux | wc -l
ps aux | wc -l
ps aux | wc -l
clear
cat /etc/passwd | cut -d: -f1 | sort | head -5
clear
ps aux | grep 'sshd' | head -5
clear
echo 'Hello World TEST' | tr '[:upper:]'
clear
echo 'Hello World TEST' | tr '[:upper:]' '[:lower:]' | sed 's/test/check'
echo 'Hello World TEST' | tr '[:upper:]' '[:lower:]' | sed 's/test/check/'
clear
echo '2*3' | bc
clear
cat fruits.txt > step1.txt
clear
echo apple
clear
echo apple > fruits.txt
vim fruits.txt 
echo banana >> fruits.txt
vim fruits.txt 
echo cherry >> fruits.txt
echo apple >> fruits.txt
echo date >> fruits.txt
echo banana >> fruits.txt
vim fruits.txt 
clear
cat fruits.txt > step1.txt
sort step1.txt > step2.txt
uniq step2.txt > step3.txt
wc -l step3.txt 
vim step2.txt 
vim step3.txt 
ls
rm -f step1.txt step2.txt step3.txt 
ls
clear
cat fruits.txt | tee pipe_step1.txt | sort | tee pipe_step2.txt | uniq | tee pipe_step3.txt | wc -l
clear
ls
rm -f pipe_step1.txt pipe_step2.txt pipe_step3.txt 
ls
clear
clear
clear
clear
clear
clear
sudo
clear
clear
sudo
clear
sudo
clear
jobs
clear
sudo
jobs
clear
jobs
sudo
clear
jobs
clear
./TESTS.sh 
./TESTS.sh 
jobs
clear
./TESTS.sh 
clear
./TESTS.sh 
sleep 10
echo $?
sleep 20
jobs
fg
fg 1
jobs
clear
sleep 10
fg 1
sleep 10
fg 1
sleep 10
fg 1
sleep 10
fg 1
sleep 10
clear
''
'     '
ls -la /home/user
ls 
ls -la /inc
clear
ls -la /home
clear
World"
clear
ls -l |
clear
"
clear
ls        -la     /home/zxerast
clear
ls
cat fruits.txt|grep "search"| wc -l
clear
'echo "hello world"'
'echo "This | is > a test"'
clear
echo "This | is > a test"
cleat
clear
echo "He said, \"Hello World\""
clear
echo Hello\ World
echo Hello\|World
clear
ls -l ||| grep "txt"
grep "search" < RomanUrievichTests.txt > output.txt 
vim output.txt 
clear
grep "search" < input.txt > output.txt 
clear
false && echo "This will not print"
true && echo "This will not print"
clear
echo "First"; echo "Second"
cat file.txt | grep "search" &
cat RomanUrievichTests.txt | grep "search" &
jobs
jobs
clear
sleep 30
jobs
jobs
clear
jobs
kill -SIGSTP 1
kill -SIGTSTP 1
jobs
jobs
bg 1
jobs
jobs
clear
sleep 30 &
kill -SIGTSTP 6546
jobs
jobs
jobs
kill -SIGTSTP 6546
jobs
jobs
jobs
jobs
clear
jobs
kill -SIGTCONT 6546
kill -SIGCONT 6546
jobs
jobs
cleaar
clear
sleep 30 &
kill -SIGCONT 6587
jobs
jobs
jobs
kill -SIGTSTP 6587
jobs
jobs
CLEAR
clear
jobs
kill -SIGCONT 6587
jobs
clear
            
""
"      "
clear
grep p
grep txt
clear
ls -l|
grep txt
ls -l|
grep txt
grep "search" > output.txt < RomanUrievichTests.txt >> append.txt -s
vim output.txt 
vim RomanUrievichTests.txt
vim output.txt 
vim append.txt 
clear
| grep "txt" || wc -l
| grep
ls | grep
|
grep
clear
cat RomanUrievichTests.txt | grep "search" &
clear
cat | grep "search" &
clear
| ls
cat | grep "search" &
jobs
jobs
jobs
jobs
jobs
clear
cat | grep "search" &
jobs
jobs
clear
echo "helloworld"
echo hellodef
