# Семестровая работа 1: Создание интерпретатора командной строки (`shell`)

## Описание

В рамках данной семестровой работы был разработан интерпретатор командной строки (shell) для Unix-подобных операционных систем. Реализация должна поддерживает выполнение простых команд, перенаправление ввода-вывода, конвейеры (pipes), встроенные команды и управление задачами (job control).

### Базовые требования
- REPL-интерфейс для ввода команд: интерактивный цикл чтения команд реализован в кастомной функции read_line, которая является обёрткой над библиотечной функцией readline и поддерживает многострочный ввод ввод при незакрытых кавычках и экранировании в конце строки. Реализация в файле input.h. Корректный выход по `EOF` (Ctrl+D) происходит в самом main в случае получения eof как результата ввода. Команда `exit` корректно вызывается. 

- Печать приглашения (prompt) в следующем формате: `username@hostname:current_directory$ ` реализовано функцией create_prompt в файле prompt.h через библиотечные getpwuid, gethostname, getcwd. Шрифт имеет красно-белый цвет.

- Поддержка комментариев: игнорирование текста после `#` выполнено нв уровне лексера в файле tokenize.h на 37 строке выход из цикла разбиения при встрече #.

- Разбиение введённой строки на лексемы (токены) и дальнейший парсинг во внутреннее представление команды (например, дерево команд) реализованы через стандартные структуры двусвязного списка(лексер) и дерева(парсер) по приоритетам токенов от самых низких как ; и & до самих команд как листьев дерева. Реализация и структуры лежат в соответствующих файлах tokenize.h, lists, ast, parser.

- Поддержка выполнения простых команд с аргументами, например: `ls -l /home` реализовано через вызов execvp в дочернем процессе - стандартный подход чтобы execvp не уничтожал адресное пространство родителя.

- Поддержка перенаправления ввода-вывода: `>`, `>>`, `<`, `&>`, `&>>` реализовано через перенаправление стандартных потоков STDIN, STDOUT через dup2 в нужный файл. Перенаправления не участвуют в парсинге команд по приоритетам, вместо этого каждый токен имеет поле под список из перенаправлений которые применяются к конкретной команде токена и перенаправляют ввод/вывод конкретно команды токена. 

- Поддержка конвейеров (pipes): `|` и `|&` осуществляется циклически, где на каждой новой итерации создаётся новый процесс под новую команду пайпа пока в пайплайне будут команды. 2 файловых дескриптора поочерёдно переоткрываются для последующих команд переводя ввод и вывод из друг в друга.

- Поддержка списков команд, разделённых `;`, `&&`, `||`, `&` также присутствует, самые простейшие if проверки на успех и поочерёдный вызов исполнителя команды.

- Всё исполнение команды находится в файле executor.c, функции названы соответствующе.

- Реализация встроенных команд: `cd`, `pwd`, `help`, `echo`, `exit` выполнено в файле builtins.c

- Поддержка управления задачами (job control): запуск задач в фоне (`&`) при котором waitpid не будет блокировать родителя до завершения дочернего процесса присутствует. Переключение между задачами через встроенные команды fg, bg есть, обработка сигналов `SIGCHLD` стоит по умолчанию для дочерних процессов, в само шелле игнорируется. Встроенные команды `jobs`, `fg`, `bg`, `kill` также находятся в builtins

- Корректная обработка ошибок: синтаксические ошибки, ошибки выполнения команд, некорректные аргументы встроенных команд и т.д. всё отслеживается, на любом этапе обработки.

- Корректное использование ресурсов: освобождение памяти, закрытие файловых дескрипторов также выполнено.

### Дополнительные требования (опционально)
- Редактирование командной строки
  - Поддержка клавиш навигации (стрелки влево/вправо) 
  - Удаление символов (Backspace, Delete) 
  - Комбинации клавиш (Ctrl+A, Ctrl+E, Ctrl+U, Ctrl+K и др.) 
- История команд
  - Сохранение истории команд в файле (например, `~/.my_shell_history`) 
  - Навигация по истории (стрелки вверх/вниз) 
  - Встроенная команда `history` 
  Всё это реализовано через стороннюю библиотеку readline

- Переменные окружения
  - Установка: `set VAR=value`
  - Просмотр: `echo $VAR`
  - Удаление: `unset VAR`
  - Специальные переменные: `$?`, `$$`, `$!`
Реализовано частично, только вариант с export VAR и подстановки, без чистого присваивания var=x.

- Многострочные команды
  - Поддержка продолжения команды на следующей строке с помощью `\` 
  - Предложение продолжения ввода (например, `> `) при незавершённой команде 
  Предложение прилагается к ситуации с незакрытыми кавычками и пустым экранированным символом.

### Оформление
- Сборка происходит через стандартный make в директории проекта
- Код размещён в системе контроля версий git
- Комментарии к блокам и краткое описание присутствует
- Код компилируется без ошибок и предупреждений
